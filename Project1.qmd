---
title: "Project 1 - Pranav and Kyra - ST558"
author: "Pranav Nair, Kyra Kapsaskis"
format: html
editor: visual
---

## Data Processing

### First steps

For the first part of our project, we are looking at some survey data about school enrollment.

First, we need to load our necessary packages

```{r}
library(tidyr)
library(dplyr)
library(tidyverse)
library(readr)
```

For our first data file, we will only be looking at some of the columns. Initially, we want to read the data in and call it, to make sure we've done this successfully.

```{r}
EDU01a <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv")
EDU01a
```

------------------------------------------------------------------------

# #1

The data looks good! So now we will select only the columns that we'd like to look at. Using the `select()` function, we can name our data frame, the columns that we want, and we can even use `starts_with` and `ends_with` to help us choose exactly what we want with a little more specificity and ease. We are creating a new object in the process so that we can do further manipulations on just these columns. We're calling the new object `EDU01a_select`.

```{r}
#1 - Select following columns
EDU01a_select <- EDU01a |>
  select("Area_name", starts_with("STC"), ends_with("D")) |>
  rename(area_name = "Area_name")

EDU01a_select
```

------------------------------------------------------------------------

# #2

We know that in this data, the column that ends with a D indicates an enrollment value for that year (with the year being the two digits before the 'D'). Going down, we see all of the enrollment values from that year, in all of the different cities. In order to make this data easier for us to read and understand, we can convert it to long format and rename the columns. What this will do, is turn the columns with this awkward long name ending with D, to simply read '`Enrollment`'. Then all of the years will be listed going down and the corresponding values will appear alongside them. This also means that there will be more than one row/observation for each city. Instead of looking all the way across the row for each city and scanning for the correct year column, we will now have individual rows/observations for city, a year, and the corresponding enrollment value. This will make things easier to process.

In order to do this conversion, we are going to simply use the `pivot_longer()` function, and its built-in arguments to achieve our goal. `Names_to` helps us give a new name to the new column **containing** the **NAMES OF THE COLUMNS** we have specified. This makes sense when you think about it because these used to be names of the columns and now they need a new name, as they have been rotated and will be located where the data is. `Values_to` helps us set a new name for the data **values** that will remain values but will just be slightly shifted to correspond to the brand new `Enrollment` column we've made.

```{r}
# using the help documentation is such a convenient way to remember what the arguments are asking for
help(pivot_longer)
```

Let's give it a whirl! And we are also creating a new object at the same time called `EDU01a_long`.

```{r}
#2 - Convert to long data
EDU01a_long <-
  pivot_longer(EDU01a_select, cols = 3:12,
               names_to = "Enrollment",
               values_to = "values")
str(EDU01a_long)
```

Scrolling through, the data looks how we want it to for now.

------------------------------------------------------------------------

# #3

The next step is to make further sense of this long Enrollment string. Two digits of the year are in there so we want to pull that out and make it look better by adding the other digits of the year.

The enrollment variable contains strings that are 10 digits long, so we are pulling out the year data with the `substr()` function, and the first 7 digits will also be pulled out as a new 'Measurement' variable.

```{r}
#3 create new variable for the 2 year digits called 'incomplete year' and then convert it to numeric so that we will be able to add 1900 to it, so it will be in date format. 

EDU01a_new <- EDU01a_long |>
      mutate(
       IncompleteYear = as.numeric(substr(Enrollment, 8, 9)),
       Measurement = substr(Enrollment, 1, 7), 
       Year = IncompleteYear + 1900) |>
      select(-IncompleteYear)

EDU01a_new
```

------------------------------------------------------------------------

# #4

The data contains both county and non-county data, so we are going to separate them. We will do that by using ", \\w\\w" to look for the character string that is in the format of the state acronym. The acronym TELLS us that it is county data (because the states don't have that). The grep() function finds patterns that match the given pattern.

We are creating an object called 'countystuff' and this will be a list of integers that match the row numbers of the county data.

```{r}
#4

# Create two data sets, one for non-county and one for county level

countystuff <- grep(pattern = ", \\w\\w", EDU01a_new$area_name)
statestuff <- grep(pattern = ", \\w\\w", EDU01a_)
```

Let's test it to see if pulling out the acronym worked!

```{r}
# looking at the output and structure of countystuff
print(countystuff)
str(countystuff)
```

Now, we can use the list we just created to indicate which rows we want in a brand new tibble called EDU01a_county. In this case, we want the 'countystuff' rows and all of the columns associated with them.

```{r}
EDU01a_county <- EDU01a_new[countystuff, ]
EDU01a_county
```

This looks great! By using the **negative sign**, we can now create a tibble for state data with the county rows REMOVED. This will just leave the non-county (or state) rows and all the columns.

```{r}
EDU01a_state <- EDU01a_new[-countystuff, ]
EDU01a_state
```

Here are the class attributes of our newly made tibble before we are going to change them.

```{r}
class(EDU01a_county)
```

Here, we are adding a class attribute called "county" to the already existing attributes. These are printed in the form of a vector.

```{r}
class(EDU01a_county) <- c("county", class(EDU01a_county))
```

```{r}
class(EDU01a_county)
```

Now, we are creating a new tibble with an additional column for the class type. In the new column, we are calling the first index so 'county' will be printed in the new class column.

```{r}
EDU01a_county_class <- EDU01a_county |>
  mutate(class_type = class(EDU01a_county)[1])

EDU01a_county_class
```

We are going to do the same thing for state/non-county data now.

```{r}
class(EDU01a_state) <- c("state", class(EDU01a_state))
```

Creating the state tibble with the new column for class that reads 'state'.

```{r}
EDU01a_state_class <- EDU01a_state |>
  mutate(class_type = class(EDU01a_state)[1])
```

Let's take a look at the new tibbles. They look great!

```{r}
print(EDU01a_county_class)
print(EDU01a_state_class)
```

------------------------------------------------------------------------

# #5

In our County tibble, we want to not only be able to see that the class type is a county, but also see what state the county is in using the state acronym. We are going to use the same substr() function as before to extract the acronym.

The negative one indicates that the 'start' index is the second to last digit, and then we are using the total number of positions in 'area_name' to indicate the 'stop' index. So this would be the last digit. That's how we are getting the last two digits for the acronym.

```{r}
#5 Creating a new column for the state abbreviation in the county tibble.

EDU01a_county_class_abb <- EDU01a_county_class |>
  mutate(abbrev_state = substr(area_name, nchar(area_name)-1, nchar(area_name)))

print(EDU01a_county_class_abb)
```

------------------------------------------------------------------------

# #6

Similarly, we want to display the division for the states. In order to do this, we are first creating a vector of all of the divisions as attributes for the state name data points.

```{r}

# we should try to turn this into a function 

#6

state_division <- c("CONNECTICUT" = "New England", 
                    "MAINE" = "New England",
                    "MASSACHUSETTS" = "New England",
                    "NEW HAMPSHIRE" = "New England",
                    "RHODE ISLAND" = "New England",
                    "VERMONT" = "New England",
                    "NEW JERSEY" = "Middle Atlantic",
                    "NEW YORK" = "Middle Atlantic",
                    "PENNSYLVANIA" = "Middle Atlantic",
                    "ILLINOIS" = "East North Central",
                    "INDIANA" = "East North Central",
                    "MICHIGAN" = "East North Central",
                    "OHIO" = "East North Central",
                    "WISCONSIN" = "East North Central",
                    "IOWA" = "West North Central",
                    "KANSAS" = "West North Central",
                    "MINNESOTA" = "West North Central",
                    "MISSOURI" = "West North Central",
                    "NEBRASKA" = "West North Central",
                    "NORTH DAKOTA" = "West North Central",
                    "SOUTH DAKOTA" = "West North Central",
                    "DELAWARE" = "South Atlantic",
                    "FLORIDA" = "South Atlantic",
                    "GEORGIA" = "South Atlantic",
                    "MARYLAND" = "South Atlantic",
                    "NORTH CAROLINA" = "South Atlantic",
                    "SOUTH CAROLINA" = "South Atlantic",
                    "VIRGINIA" = "South Atlantic",
                    "District of Columbia" = "South Atlantic",
                    "DISTRICT OF COLUMBIA" = "South Atlantic",
                    "WEST VIRGINIA" = "South Atlantic",
                    "ALABAMA" = "East South Central",
                    "KENTUCKY" = "East South Central",
                    "MISSISSIPPI" = "East South Central",
                    "TENNESSEE" = "East South Central",
                    "ARKANSAS" = "West South Central",
                    "LOUISIANA" = "West South Central",
                    "OKLAHOMA" = "West South Central",
                    "TEXAS" = "West South Central",
                    "ARIZONA" = "Mountain",
                    "COLORADO" = "Mountain",
                    "IDAHO" = "Mountain",
                    "MONTANA" = "Mountain",
                    "NEVADA" = "Mountain",
                    "NEW MEXICO" = "Mountain",
                    "UTAH" = "Mountain",
                    "WYOMING" = "Mountain",
                    "ALASKA" = "Pacific",
                    "CALIFORNIA" = "Pacific",
                    "HAWAII" = "Pacific",
                    "OREGON" = "Pacific",
                    "WASHINGTON" = "Pacific")
```


```{r}

# Kyra taking a stab at turning the above into a function...

# division only
# x <- unname(state_division)
# 
# # state only
# y <- names(state_division)
# 
# state_div_function <- function(y, x){
#   if (y[1:6])
#     (y, x[1]),
#   if (y[7:14]
#       (y, x[7])
# }
```


```{r}
# x
# y
```

We have created a vector of named character strings called state_division.

```{r}
str(state_division)
```

Here we are using a vectorized function to create our new tibble with the state division. The mutate() function allows us to create a new column, and the ifelse vectorized function is basically saying, in the vector state_division, if the names of the vector elements matches the area_name variable, it will return what is found in that next position in the function... the area_name value that is in the state_division vector.

Finally, the very last position in the function says what will be returned if there IS NOT a match- "Error".

```{r}
EDU01a_state_class_division <- EDU01a_state_class |>
  mutate(division = ifelse(area_name %in% names(state_division),
                           state_division[area_name],
                           "Error"))  

print(EDU01a_state_class_division)
```

### Hooray! It is showing the Division in our new column!

### This wraps up our pre-processing steps. Now, we will write functions that combine and repeat these steps so we can quickly and efficiently make these changes with a *new data set.*

------------------------------------------------------------------------

### Function for steps 1 and 2

```{r}
#function for steps 1 and 2
print(EDU01a)

  step_1_2 <- function(data, value_col_name = "enrollment") {
    data |>
      select(Area_name, starts_with("STC"), ends_with("D")) |>
      rename(area_name = Area_name) |>
      pivot_longer(cols = ends_with("D"), names_to = "measurement_year", values_to = value_col_name)
     
  }

step1result <- step_1_2(EDU01a)
print(step1result)
```

------------------------------------------------------------------------

### Function for step 3

```{r}
step_3 <- function(data) {
  data |>
        mutate(
       IncompleteYear = as.numeric(substr(measurement_year, 8, 9)),
       Measurement = substr(enrollment, 1, 7), 
       Year = IncompleteYear + 1900) |>
      select(-enrollment, -IncompleteYear)
}
step3result <- step_3(step1result)
print(step3result)

```

------------------------------------------------------------------------

### Function for step 5

```{r}
step_5 <- function(data) {
    data |>
      mutate(state = ifelse(grepl(", \\w\\w", area_name), substr(area_name, nchar(area_name) - 1, nchar(area_name)), NA))
  }
```

------------------------------------------------------------------------

### Function for step 6

```{r}
# GABBY COMMENT: could just put 'state' instead of state division (?)
  
  step_6 <- function(data, div = state_division) {
    data |> 
      mutate(division = ifelse(area_name %in% names(state_division),
                        state_division[area_name],
                        "Error"))  

  }
```

------------------------------------------------------------------------

#### Another 2 functions that take in the output from step 3 and creates the two tibbles in step 4, calls the above two functions (to perform steps 5 and 6), and returns two final tibbles.

```{r}
create_two_datasets <- function(data) {
    county_filter <- grep(pattern = ", \\w\\w", data$area_name)
    county_data <- data[county_filter, ]
    non_county_data <- data[-county_filter, ]
    
    class(county_data) <- c("county", class(county_data))
    class(non_county_data) <- c("state", class(non_county_data))
    
    list(county_data = county_data, non_county_data = non_county_data)
  }
```

```{r}
# process_data <- function(data, state_division) {
#     long_data <- step_1_2(data)
#     
#     parsed_data <- step_3(long_data)
#       
#     datasets <- create_two_datasets(parsed_data)
#     county_data <- datasets$county_data
#     non_county_data <- datasets$non_county_data
#     
#     county_data <- step_5(county_data)
#     
#     non_county_data <- step_6(non_county_data, state_division)
#     
#     list(county_data = county_data, non_county_data = non_county_data)
#   }
```

```{r}
# WRAPPER FUNCTION SYNTAX

wrapper_function <- function(url, value_col_name = "enrollment") {
#   
  result <- read_csv(url) |>
#   
   step_1_2() |>
#   
   step_3() |>
#   
   step_5() |>
#   
   step_6() |>
  
#   
   create_two_datasets()
#   
   #process_data()
 }


wrapper_function("https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv")
wrapper_result <- print(wrapper_function("https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv", "enrollment"))

#create_two_datasets(df1, df2)|>
  #create_two_datasets(df3, df4)
  

# GABBY COMMENT: put the functions together to where you just list the functions and don't need arguments, instead of including all of the steps within each function. Shouldn't have to have all the state division stuff in the wrapper function.

# my_wrapper <- function(url, value_col_name = "enrollment") {
#   data <- read_csv(url)
# 
#   # can this step be made into a function?
#   state_division <- c("CONNECTICUT" = "New England",
#                       "MAINE" = "New England",
#                       "MASSACHUSETTS" = "New England",
#                       "NEW HAMPSHIRE" = "New England",
#                       "RHODE ISLAND" = "New England",
#                       "VERMONT" = "New England",
#                       "NEW JERSEY" = "Middle Atlantic",
#                       "NEW YORK" = "Middle Atlantic",
#                       "PENNSYLVANIA" = "Middle Atlantic",
#                       "ILLINOIS" = "East North Central",
#                       "INDIANA" = "East North Central",
#                       "MICHIGAN" = "East North Central",
#                       "OHIO" = "East North Central",
#                       "WISCONSIN" = "East North Central",
#                       "IOWA" = "West North Central",
#                       "KANSAS" = "West North Central",
#                       "MINNESOTA" = "West North Central",
#                       "MISSOURI" = "West North Central",
#                       "NEBRASKA" = "West North Central",
#                       "NORTH DAKOTA" = "West North Central",
#                       "SOUTH DAKOTA" = "West North Central",
#                       "DELAWARE" = "South Atlantic",
#                       "FLORIDA" = "South Atlantic",
#                       "GEORGIA" = "South Atlantic",
#                       "MARYLAND" = "South Atlantic",
#                       "NORTH CAROLINA" = "South Atlantic",
#                       "SOUTH CAROLINA" = "South Atlantic",
#                       "VIRGINIA" = "South Atlantic",
#                       "District of Columbia" = "South Atlantic",
#                       "DISTRICT OF COLUMBIA" = "South Atlantic",
#                       "WEST VIRGINIA" = "South Atlantic",
#                       "ALABAMA" = "East South Central",
#                       "KENTUCKY" = "East South Central",
#                       "MISSISSIPPI" = "East South Central",
#                       "TENNESSEE" = "East South Central",
#                       "ARKANSAS" = "West South Central",
#                       "LOUISIANA" = "West South Central",
#                       "OKLAHOMA" = "West South Central",
#                       "TEXAS" = "West South Central",
#                       "ARIZONA" = "Mountain",
#                       "COLORADO" = "Mountain",
#                       "IDAHO" = "Mountain",
#                       "MONTANA" = "Mountain",
#                       "NEVADA" = "Mountain",
#                       "NEW MEXICO" = "Mountain",
#                       "UTAH" = "Mountain",
#                       "WYOMING" = "Mountain",
#                       "ALASKA" = "Pacific",
#                       "CALIFORNIA" = "Pacific",
#                       "HAWAII" = "Pacific",
#                       "OREGON" = "Pacific",
#                       "WASHINGTON" = "Pacific")
# 
#   result <- process_data(data, state_division)
# 
#   result
# }




```

Write a generic function for Summarizing

```{r}
library(ggplot2)
  plot_state <- function(data, var_name = "enrollment") {
    filter_data <- data |>
      filter(division != "ERROR")
    
    data_summary <- filter_data |>
      group_by(Year, division) |>
      summarize(mean_value = mean(get(value_col_name)))
    
    plot <- ggplot(data_summary, aes(x = Year, y = get(var_name), color = division)) + geom_line() + labs(x = "Year", y = "Mean Value", title = "Line Plot")
    
    return(plot)
      
  }
  
plot_state(wrapper_result$non_county_data)


# GABBY COMMENT (no need to make changes, just general comment): Initializing, defining the default. would only need 'data' argument. if it was a different state, then would need to put the state you want, NC has been initialized as the default. 

plot_county <- function(data, state2 = "NC", var_name = "enrollment", top_bottom_county = "top", num_of_county = 5) {

  data_state <- data |>
    filter(state == state2)
   
    if(top_bottom_county == "top") {
       mean_values <- data_state |> 
        group_by(area_name) |>
        summarize(mean_value = mean(get(var_name), na.rm = TRUE)) |>
        arrange(desc(mean_value)) 
    }
      else if(top_bottom_county == "bottom") {
        mean_values <- data_state |> 
          group_by(area_name) |>
          summarize(mean_value = mean(get(var_name), na.rm = TRUE)) |>
          arrange(desc(mean_value, FALSE))
      }

  
 # GABBY COMMENT: THIS IS WHY PLOT ISNT WORKING
  #we want to use mean_value with a dollar sign to extrapolate the area_name from the variable. we are importing the num of county and then only take the rows up until that number so if it were 10 it would be 1:10 (this is an EXAMPLE where 10 is num of county). this would be 1:num_of_county so it can be whatever the variable is.   
    areas_select <- mean_values$area_name[1:num_of_county]
     
     # head(1:num_of_county) |> remove this, head() is another form of Print(), first 6 obs
    
    plot_data <- data_state |>
      filter(area_name %in% areas_select)
    
 # GABBY COMMENT: y = get(var_name)
    
    plot <- ggplot(plot_data, aes(x = Year, y = get(var_name), color = area_name)) + geom_line() + labs(x = "Year", y = "Mean Value", title = "Line Plot")
  
    return(plot)  
}
  
# function()

plot_county(wrapper_result$county_data,state = "NC", var_name = "Measurement", top_bottom_county = "top", num_of_county = 5)

print(wrapper_result$county_data)
```

```{r}
# create function for plotting state
  plot_state()

```
